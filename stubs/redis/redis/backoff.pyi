from abc import ABC, abstractmethod

class AbstractBackoff(ABC):
    def reset(self) -> None: ...
    @abstractmethod
    def compute(self, failures: int) -> int: ...

class ConstantBackoff(AbstractBackoff):
    def __init__(self, backoff: int) -> None: ...
    def compute(self, failures: int) -> int: ...

class NoBackoff(ConstantBackoff):
    def __init__(self) -> None: ...

class ExponentialBackoff(AbstractBackoff):
    def __init__(self, cap: int, base: int) -> None: ...
    def compute(self, failures: int) -> int: ...

class FullJitterBackoff(AbstractBackoff):
    def __init__(self, cap: int, base: int) -> None: ...
    def compute(self, failures: int) -> int: ...

class EqualJitterBackoff(AbstractBackoff):
    def __init__(self, cap: int, base: int) -> None: ...
    # Technically it returns `float`,
    # but `# type: ignore[override]` seems like an overkill.
    def compute(self, failures: int) -> int: ...

class DecorrelatedJitterBackoff(AbstractBackoff):
    def __init__(self, cap: int, base: int) -> None: ...
    def compute(self, failures: int) -> int: ...
